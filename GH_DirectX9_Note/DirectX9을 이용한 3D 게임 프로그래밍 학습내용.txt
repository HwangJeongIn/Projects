DirectX9을 이용한 3D게임 프로그래밍 완료

학습 목록

- 기본적인 컴퓨터 사이언스에서 필요한 지식에 대해서 학습
	벡터			// 위치와 방향을 표시, 평면과의 관계, 내적, 외적, 광선표현
	행렬			// 여러가지 변환, 변환 조합, 반대연산 등
	기본적인 세팅과정	// 컴파일하기 위해 설정해줘야할 것들 학습 / 기본적인 Device만드는 과정
	기타 간단한 원리와 사용법	// 스왑체인, 밀티 샘플링, 픽셀 포맷, 깊이버퍼, 메모리 풀 
	
	// 스왑체인은 내부적으로 알아서 관리
	원리는 먼저 전면 버퍼 슬롯의 표면은 현재 모니터 디스플레이 되는 이미지와 대응된다.
	근데 속도에 따라서 문제가 발생할 수 있는데 애플리케이션프레임율과 모니터의 재생율이 동기화 되지않는 경우
	디스플레이를 마칠때 까지 렌더링을 멈춘다든지 / 완전히 디스플레이 하지 못한 상태에서 다음프레임으로 갱신하는 경우 발생
	
	이때 후면버퍼에서 렌더링하고 전면 버퍼 디스플레이가 완료되면 스왑체인의 끝으로 돌아가 후면 버퍼를 전면 버퍼로 전환하는 방법을 이용 // presenting		

- 렌더링 파이프라인
	버텍스 포맷

	// 전체적인 과정
	3d물체들은 로컬 스페이스 내에 정의 
	-> 월드 스페이스 시스템으로 옮겨짐
	-> 투영을 위해 추려내기와 같은 작업 (클리핑) 

	* 뷰스페이스 변환행렬
	-> 뷰스페이스 좌표계로 물체를 변환(카메라 원점 + 양의 z축을 내려다보도록하는 과정 진행)
	// D3DXMatrixLookAtLH(v, 카메라위치, 보는 지점, up벡터) >> Device->SetTransform(D3DTS_VIEW, &v)

	* 투영행렬
	-> 뷰스페이스 내에 놓여진 물체들은 투영 윈도우로 투영 // 이때 z값은 일반적으로 1이다. // 뷰 스페이스 중심(현재 0,0,0)에서 투영창까지 거리가 1
	// 이때 3D를 z값이 일정수치로 고정된 좌표를 얻게되므로 3D>2D라고 말할 수 있다.
	// D3DXMatrixPerspectiveFovLH(proj, 시야각, 종횡비, 각 절단면까지의 거리) >> Device->SetTransform(D3DTS_PROJECTION, &proj)

	* 뷰 포트 변환행렬
	-> 뷰 포트 변환을 통해 투영 윈도우의 기하물체가 뷰포트로 변환 // 이때 z값이 날아간다.
	// proj의 proj(0,0)이 x의 배율을 proj(1,1)이 y의 배율을 조절해서 뷰포트로 변환한다.
	// D3DVIEWPORT vp = {X(시작지점), Y(시작지점), 너비, 높이, 깊이버퍼 최소, 깊이버퍼 최대} >> Device->SetViewPort(&vp)

	* 주의해야할 점
	-> 버텍스 구조체를 정의할 때 버텍스 구조체에 정의된 데이터 순서와 FVF의 정의된 순서는 반드시 일치해야한다.
	ex) (D3DFVF_XYZ | D3DFVF_DIFFUSE) <-> struct ColorVertex{float x, float y, float z, DWORD color}
	// 이런식으로 매칭되어야 한다.
	-> 만약에 FVF형식을 쓰지 않으려면 버텍스 선언 형식을 정의해야한다. 이는 어느간격으로 어떤 정보가 들어가 있는지 선언해주는 것이다.
	ex)
	// 아래와 같이 좀더 자세한 버텍스 형식을 지정할 수 있다.
		D3DVERTEXELEMENT9 decl[] = 
		{
			{0, 0, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_POSITION, 0},
			{0, 12, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_NORMAL, 0},
			{0, 24, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_NORMAL, 0},
			{0, 36, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_NORMAL, 0},
		}
	// Device->SetVertexDeclaration(_decl);

	* 렌더링의 예시
	// 간단한 도형 출력하기
	그리기 전 세팅

		버텍스 버퍼를 만든다.
		인덱스 버퍼를 만든다.

		버텍스 버퍼 락
			버텍스 정보를 설정
		버텍스 버퍼 언락

		인데스 버퍼 락
			인덱스 정보를 설정
		인덱스 버퍼 언락

		투영행렬 정의
		뷰포트 행렬 정의


	그리기(매 프레임 실행)

		뷰스페이스 행렬은 애플리케이션의 특성에 따라 계속 바뀔수 있으므로 업데이트될 수 있다.

		물체에 대한 행렬을 월드 기준으로 적용시켜준다.

		깨끗하게 지워준다.

		씬 시작
			소스스트림 설정(버텍스)
			인덱스 설정
			FVF 설정 // FVF사용시
			텍스처 설정 // 텍스처 사용시
			그려준다.
		씬 끝


	클리어(애플리케이션 종료시)

		동적할당했던 모든 데이터를 릴리즈

- 칼라

- 조명

	* 빛의 종류
	// 환경광 : 다른 표면에 반사되어 전반적인 장면을 밝게 하는 빛 // 저렴, 간단
	Ambient Light

	// 난반사광 : 특정한 방향으로 진행하며, 표면에 닿으면 모든 방향으로 동일하게 반사 
	// 모든 방향으로 동일하게 반사되므로 위치와는 관계없이 관찰자의 눈에 빛이 도달하고 관찰자의 위치 고려할 필요X
	// 방정식에는 빛의 방향과 표면의 형태만 고려되면 된다.
	Diffuse Light

	// 정반사광 : 특정한 방향으로 진행하며, 포면에 닿으면 한 방향으로 강하게 반사하여 특정한 각도에서만 관찰가능
	// 방정식에서는 빛의 방향과 표면의 형태, 그리고 관찰자의 시점 모두를 고려
	Specular Light

	* 조명 켜고 끄기
	Device->SetRenderState(D3DRS_SPECULARENABLE, true / false);

	* 재질설정
	typedef struct _D3DMATERIAL9
	{
		D3DCLORVALUE Diffuse, Ambient, Specular, Emissive;
		float Power
	} D3DMATERIAL9

	// 여기서 Emissive는 전반적인 표면의 컬러를 더하는데 사용되며,
	// 물체 자체가 빛을 발하는 것처럼 좀더 밝은 물체효과를 만들어 낸다.
	
	* 법선벡터 구하기
	버텍스의 법선벡터는 면의 법선 벡터로 구하면된다. 
	이때 면의 법선벡터는 시계 방향 두르기 기준으로 (p1 - p0) X (p2 - p0)는 면기준 윗방향 벡터이다.

	좀더 자연스러운 법선 벡터를 구하기 위해서 예를들어 한 버텍스를 공유하는 3개의 면이 있다고 가정하면
	그 버텍스의 법선벡터는 (n1 + n2 + n3)/3으로 구할 수 있다.

	* 광원

	- 방향성 광원(Directional Light)
		: 지정된 방향으로 평행하게 빛을 발산한다. // 위치지정X, 방향지정O

	- 스포트 광원(Spot Light)
		: 위치를 가지며, 특정한 방향으로 원뿔형태의 빛을 발산 // 안쪽원뿔과 바깥원뿔의 각도, 방향지정O
	
	- 점 광원(Point Light)
		: 위치를 가지며 모든방향으로 빛을 발산한다. // 위치지정O, 방향지정X

	typedef struct _D3DLIGHT9
	{타입, 난반사광, 정반사공, 환경광, 위치, 방향, 범위(방향성은 의미X), 안쪽원뿔과바깥원뿔간 빛의 세기 차이, 감쇠, 안쪽원뿔각, 바깥원뿔각}

- 텍스처링

	* 필터
	텍스처와 어떻게 매핑되는지에 대한 설정을 해준다.
	예를 들어 텍스처 삼각형과 스크린 삼각형의 크기가 서로 다른데, 텍스처 삼각형이 작을때는 확대하고 크면 축소한다.
	그 과정에서 왜곡이 발생하는데, 필터링을 통해 이와 같은 왜곡 현상을 줄이고 부드러운 이미지를 만들어 낼 수 있다.

	Device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_XXXXXX);
	// 오른쪽으로 갈수록 느리지만 품질이 좋다 // POINT > LINEAR > ANISOTROPIC 

	* 밉맵
	위의 경우 삼각형의 크기가 급격하게 변하는 현상이 발생할 수 있다 
	그를 막기위해 디테일을 보존하면서 여러개의 작은 해상도로 텍스처로 만드는 방식이다.

	* 밉맵필터
	POINT : 가장 비슷한 크기의 밉맵 레벨을 선택 / LINEAR : 두개의 밉맵 레벨에 min과 mag 필터링을 적용 > 조합 > 최종픽셀컬러

	* 텍스처 좌표를 넘어갈 경우 정의([0,1]을 넘어가면)
	wrap, border, color, clamp, mirror의 종류가 있다

- 블렌딩

	두개의 픽셀컬러를 조합

	* 블렌드 인수
	원본 블렌드 인수와 목적지 블렌드 인수를 지정하여 다양한 효과를 만든다.
	
	* 투명
	// 알파 성분으로 픽셀의 투명도를 지정하기 위해서 지정 
	Device->SetRenderState(D3DS_SRCBLEND, D3DBLEND_SRCALPHA) 
	Device->SetRenderState(D3DS_DESTBLEND, D3DBLEND_INVSRCALPHA)
	
	* 알파 채널
	셰이딩에서 계산된 알파 성분을 이용하는 방법 이외에 텍스처의 알파 채널에서 알파 정보를 얻을 수 있다.
	// 이때 알파 정보를 포함하는 DDS파일로 사용한다.

	// 셰이드 과정에서 난반사 컬러로 알파를 계산
	Device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
	Device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTA_SELECTRAG1);
	
	// 알파 채널에서 알파를 얻어온다
	Device->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	Device->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTA_SELECTRAG1);
	

	* 주의
	상당한 작업이 필요하기 때문에, 이를 필요로하는 곳에만 켜서 모두 처리하고 꺼줘야한다.

- 스텐실

특수한 효과를 위한 오프 스크린버퍼
동일한 해상도를 가지기 때문에 후면버퍼와 깊이 버퍼의 ij번째 픽셀과 대응된다.

* 스텐실 상태 설정
Device->SetRenderState(D3DRS_STENCILENABLE, true or false);

* 스텐실 테스트
스텐실 테스트란 특정 픽셀에 대해 작업을 해주기 위해 그게 우리가 원하는 픽셀인지 찾기위한 작업이다.

// 식
// 스텐실 참조값(사용자 정의), 스텐실 값, 
// 마스크와 비교연산자(사용자 정의) 의해 특정 픽셀을 판별해낸다.
// 스텐실 값 : (스텐실 테스팅을 수행하고 있는 현재 픽셀의 시텐실 버퍼 값, ij번째 픽셀 테스트 중이라면 스텐실 버퍼의 ij값)

(참조 & 마스크) 비교연산자(사용자정의) (값 & 마스크)

* 스텐실 테스트에 실패 / 성공에 따른 처리 설정
// 예를들어 그림자를 렌더링할떄 중복렌더링을 막기위해 성공했을때 참조값을 증가시켜서 또 같은픽셀에 테스트를 하려고하면 실패하게 만든다.
// 이를 통해 겹치는 부분에 대해서 그림자를 한번만 렌더링할 수 있다.

- 글꼴

- 메쉬

* 형식지정 // FVF / VertexDeclaration

* 서브셋 / 속성버퍼
서브셋이란 동일한 속성을 이용해 렌더링 할 수 있는 메쉬 내 삼각형들의 그룹 // 속성 : 재질, 텍스처, 렌더상태
메쉬내 삼각형들은 각 삼각형이 위치를 나타내는 서브셋을 지정하는 속성 ID가진다. // 속성테이블을 받아서 직접 지정할수있다.

삼각형i
= 인덱스 버퍼내 i*3, i*3+1, i*3+2 와 대응

따라서 인덱스들은 거기에 맞는 삼각형의 서브셋ID를 가진다.

* 최적화
효과적으로 메쉬를 렌더링 하기 위해서 버텍스와 인덱스를 재구성하는 작업
다양한 최적화 플래그 존재

최적화 하기위해서는 주어진 삼각형과 인접한 다른 삼각형에 대한 정보가 필요

삼각형		0				1				2				

인접배열	-1	-1	1		0	-1	2		-1	-1	1

// 없을때는 -1을 넣어준다 이는 DWORD -1 == ULONG_MAX(4294967295)

최적화되지 않은 인접 배열로 > 최적화된 메쉬의 인접 정보 + 원래i번째 항목이 어디에 이동했는지 알려주는 정보(버텍스, 면)

플래그 D3DXMESHOPT_ATTRSORT 플래그를 설정하여 메쉬를 최적화하면 메쉬의 기하정보가 그 속성에 따라 정렬
버텍스 / 인덱스 버퍼내 특정부분의 기하 정보가 연속된 블록에 위치

삼각형	0	1	2	3	4	5	6	7

서브셋	0	0	0	1	1	2	2	2

* 파일을 읽어서 메쉬객체로 변환 가능

* 프로그레시브 메쉬
ECT(edge collapse transformation) 시퀀스이란 적용하여 메쉬를 단순화할 수 있도록 해준다.
이를 이용해서 카메라와의 거리에 따라서 LOD 조정할 수 있다.

* 경계볼륨
D3DX라이브러리에서 경계볼륨을 계산하는 함수를 제공한다.
이를 이용해 그 경계볼륨안에있는지 확인하는 작업처리를 해줄 수 있다.

- 카메라

// 우향 벡터기준으로 회전
pitch // 나머지 상향 전방 벡터를 회전시킨다.

// 상향 벡터 기준으로 회전
yaw // 나머지 우향 전방 벡터를 회전시킨다.

// 전방 벡터 기준으로 회전
roll // 나머지 상향 우방 벡터를 회전시킨다.

* 이동과 회전을 해주는 행렬이 필요하다 // 뷰스페이스 변환행렬 계산
이동 : 카메라의 위치 기준으로 간단히 해줄수 있다.
회전 : x, y, z를 정렬하는 행렬이 필요하다 / 즉 현재 우향벡터 * 행렬 = 1,0,0 
// 정규직교기저에 대한 성질을 이용해서 전치행렬과 역행렬이 같다는 결론을 도출해내고 그로인해 행렬을 계산한다.


- 지형렌더링

높이맵(height map)을 이용하면 지형렌더링을 텍스처에 의해 할수 있다.
이런 높이맵의 그래픽적인 표현중 하나로 낮은 고도를 어두운 값으로 높은 고도를 밝은 값으로 표현하는 그레이 스케일 맵이 있다.

- 픽킹

스크린 좌표를 이용해 선택한 물체를 알아내는 테크닉이다.

스크린 포인트 s를통해 투영창에 대응되는 p 얻는다 -> 원점에서 출발하여 p를 통과하여 발사되는 광선 계산(뷰스페이스 기반)
-> 픽킹 광선과 모델을 동일한 공간으로 변환 -> 픽킹 광선과 교차하는 물체를 알아낸다.


- 파티클 시스템

작은 입자들로 표현되는 현상을 모델링 할 때 사용된다.

- 셰이더

	* HLSL // 고수준 셰이딩 언어 사용
	// 많은 행렬계산에 특화되어있으며, GPU내에서 실행되기 때문에 빠르다.

	* 입력형식과 반환형식
	입력형식과 반환형식을 지정해야하는데, 예시는 다음과 같다
	struct INPUT
	{
		float3 pos : POSITION // POSITION0
		float2 tex : TEXCOORD // TEXCOORD0
		float2 tex1 : TEXCOORD1
		float2 tex2 : TEXCOORD2
	}
	이는 셰이딩 코드 내부이며 외부 애플리케이션에서 버텍스형식 선언을 지정 해준다.

		// 아래와 같이 좀더 자세한 버텍스 형식을 지정할 수 있다.
		D3DVERTEXELEMENT9 decl[] = 
		{
			{0, 0, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_POSITION, 0},
			{0, 12, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_NORMAL, 0},
			{0, 24, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_NORMAL, 0},
			{0, 36, D3DECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DECLUSAGE_NORMAL, 0},
		}
	// Device->SetVertexDeclaration(_decl);
	이런식으로 지정해주면  D3DECLUSAGE_POSITION, 0 <-> float3 pos : POSITION 과 매칭된다.

	* 시작점 함수
	셰이더 코드내 시작점함수를 컴파일시 알려주면 그 함수기반으로 돌아간다.

	버텍스 셰이더
	픽셀 셰이더	

- 이펙트 프레임워크

	여러가지 렌더상태를 적용하고 싶을때, 내부 파라미터를 이용해 셰이더 텍스처 등을 적용할 수 있다. 

	* 사용법
	이펙트 객체를 만든다 -> 테크닉 핸들을 이름으로 얻고 -> 테크닉을 설정 -> 이펙트 시작점 -> 패스지정 -> 그린다 -> 이펙트 종료점 

	* 예시
	// 내부 셰이딩 코드도 포함 가정

	technique T0
	{
		pass p0
		{
		// 패스의 장치상태, 셰이더, 샘플러 등의 지정
		}

	}

	technique T2
	{
		pass p0
		{
		// 패스의 장치상태, 셰이더, 샘플러 등의 지정
		}

		pass p1
		{
		// 패스의 장치상태, 셰이더, 샘플러 등의 지정
		// vertexShader = compile vs_2_0 Main(); // 이런식으로 직접 컴파일 가능하다. 단 한파일내에 모두 있어야함
		}
	}