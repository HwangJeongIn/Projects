////////////////////////////////////////////////////////////////////////////
// 
// File: diffuse.txt
// 
// Author: Frank Luna (C) All Rights Reserved
//
// System: AMD Athlon 1800+ XP, 512 DDR, Geforce 3, Windows XP, MSVC++ 7.0 
//
// Desc: Vertex shader that does diffuse lighting.
//          
////////////////////////////////////////////////////////////////////////////

//
// Global variables we use to hold the view matrix, projection matrix,
// ambient material, diffuse material, and the light vector that describes
// the direction to the light source.  These variables are initialized from
// the application.
//

// 뷰행렬, 투영행렬, 환경 재질, 난반사 재질, 광원의 방향을 나타내는 조명벡터
// 애플리케이션에서 초기화된다.
matrix ViewMatrix;
matrix ViewProjMatrix;

vector AmbientMtrl;
vector DiffuseMtrl;

vector LightDirection;

//
// Global variables used to hold the ambient light intensity (ambient
// light the light source emits) and the diffuse light intensity (diffuse
// light the light source emits).  These variables are initialized here
// in the shader.
//

// 조명의 강도를 보관하는 전역변수
vector DiffuseLightIntensity = {0.0f, 0.0f, 1.0f, 1.0f};
vector AmbientLightIntensity = {0.0f, 0.0f, 0.2f, 1.0f};

//
// Input and Output structures.
//

struct VS_INPUT
{
// 법선벡터가 들어오면
    vector position : POSITION;
    vector normal   : NORMAL;
};

struct VS_OUTPUT
{
// 계산을 해서 난반사광을 포함한 포맷으로 반환한다.
    vector position : POSITION;
    vector diffuse  : COLOR;
};

//
// Main
//
/*
버텍스 셰이더로 입력되는 버텍스가 지역 좌표를 가지며, 버텍스 셰이더는 조명을 입힌
버텍스를 동종 클립 스페이스로 출력해야한다.
지역스페이스 버텍스 > 동종 클립 스페이스 // 월드 변환 > 뷰변환 > 투영변환을 차례로 거처야한다.
*/

VS_OUTPUT Main(VS_INPUT input)
{
    // zero out all members of the output instance.
	// 지역변수로 반환객체를 초기화한다
    VS_OUTPUT output = (VS_OUTPUT)0;

    //
    // Transform position to homogeneous clip space
    // and store in the output.position member. 
    //

	// position을 동종 클립 공간으로 변환하고 이를 output.position 멤버에 보관한다.
    output.position = mul(input.position, ViewProjMatrix);

    //
    // Transform lights and normals to view space.  Set w
    // componentes to zero since we're transforming vectors 
    // here and not points.
    //

	// 전역변수 접근시 문제가 생긴다?
	// 찾은 자료1

	/*
	uniform 키워드를 접두어로 붙이면 변수가 셰이더 외부
	예를 들어 C++애플리케이션에서 초기화되어 셰이더에 입력됨을 의미한다.

	원래 전역 uniform 변수를 수정하는 것은 불가능하다.
	전역 uniform변수를 수정하는 코드가 나올때는
	오래된 버전에서는 알아서 바꿔주지만 최적화하여 지역변수를 생성해서 처리해주지만
	새로운 버전에서는 직접 바꾸도록 하여야한다.
	
	그렇기 때문에 오래된버전기준으로 작성된 코드는 최신버전에서 오류가 생긴다.
	호환가능한 플래그인 D3DXSHADER_ENABLE_BACKWARDS_COMPATIBILITY을 사용한다.

	찾은 자료에서는 uniform키워드 붙은 것 기준으로 설명하였지만 
	전역변수도 변경할수 없는 것은 마찬가지일것이다.
	*/

	// 벡터를 계산할것이기 떄문에 w값을 0으로 초기화한다.
	// 위치기준으로 계산하려면 w를 1로 초기화해야한다.
    LightDirection.w = 0.0f;
    input.normal.w   = 0.0f;

	// 뷰행렬을 곱해서 뷰에 맞는 방향을 정해준다. // 방향만
    LightDirection   = mul(LightDirection, ViewMatrix);
    input.normal     = mul(input.normal,   ViewMatrix);

    //
    // Compute cosine of the angle between light and normal.
    //

	// 들어온 법선벡터와 빛의 방향의 내적을 구해준다.
    float s = dot(LightDirection, input.normal);

    //
    // Recall that if the angle between the surface and light
    // is greater than 90 degrees the surface recieves no light.
    // Thus, if the angle is greater than 90 degrees we set
    // s to zero so that the surface will not be lit.
    //
	
	/*
	0 ~ 90 : +
	90 ~ 270 : -
	270 ~ 360 : +
	*/

	// 각도가 90도가 넘는 경우는 s를 0으로 지정하여
	// 빛을 받지 못하도록 하였다.
	// 270 ~ 360인경우에는 어떤식으로 돌아갈까?
    if( s < 0.0f )
        s = 0.0f;

    //
    // Ambient light reflected is computed by performing a 
    // component wise multiplication with the ambient material
    // vector and the ambient light intensity vector.
    //
    // Diffuse light reflected is computed by performing a 
    // component wise multiplication with the diffuse material
    // vector and the diffuse light intensity vector.  Further
    // we scale each component by the shading scalar s, which
    // shades the color based on how much light the vertex received
    // from the light source.
    //
    // The sum of both the ambient and diffuse components gives
    // us our final vertex color.
    // 

	/*
	반사되는 환경광
	 : 환경 재질 벡터와 환경 광원 강도 벡터간의 성분 단위의 곱

	반사되는 난반사광
	 : 난반사 재질 벡터와 난반사 광원 강도 벡터간의 성분 단위의 곱

	 여기에 각각의 버텍스가 광원으로부터 받은 빛의 양을 조절하는 셰이딩 스칼라 s로 각 성분의 크기 조정

	 최종값
	  : 환경 + 난반사 성분의 합
	*/
    output.diffuse = (AmbientMtrl * AmbientLightIntensity) +
                     (s * (DiffuseLightIntensity * DiffuseMtrl));

	// 여기서 s는 빛의 방향과 법선벡터의 내적값이다.
	// 두사이의 각도가 0 : 1의 값을 가진다
	// 두사이의 각도가 90이상 : 0의 값을 가진다.
	// 두사이의 각도가 0-90 : 0과 1사이의 값을 가진다.
    
    return output;
}





